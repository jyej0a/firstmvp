# 멘토링 주제 후보 (실제 개발 중 나온 질문들)

> **대비마마를 위한 멘토링 질문 모음**  
> 실제 프로젝트를 진행하면서 나온 구체적인 질문들을 정리했습니다.

---

## 🔧 카테고리 1: 순차 처리 구현 중 실제로 겪은 문제들

### 질문 1-1: 백그라운드 작업을 어떻게 시작하나요?

**실제 상황:**

- `sequential-scraper.ts` 파일 122번 줄을 보면:
  ```typescript
  processSequentialScraping(job.id, userId, searchInput, totalTarget).catch(...)
  ```
- 이렇게 `.catch()`만 붙이고 `await`를 안 쓰는데, 이게 맞나요?

**궁금한 점:**

- `await`를 안 쓰면 서버가 응답을 보낸 후에도 작업이 계속 진행되나요?
- 만약 `await`를 쓰면 어떻게 되나요? (사용자가 30분 동안 기다려야 하나요?)
- `.catch()`로 에러를 잡는 게 충분한가요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 122번 줄

---

### 질문 1-2: 사용자가 화면을 닫아도 작업이 계속 진행되나요?

**실제 상황:**

- 사용자가 "수집 시작" 버튼을 누르고 화면을 닫으면
- 백그라운드에서 작업이 계속 진행되는지 궁금합니다

**궁금한 점:**

- Next.js 서버에서 시작한 작업은 사용자가 화면을 닫아도 계속 되나요?
- 아니면 사용자가 연결을 끊으면 작업도 중단되나요?
- 나중에 다시 접속했을 때 진행 상황을 볼 수 있나요?

---

### 질문 1-3: 취소 기능은 어떻게 구현하나요?

**실제 상황:**

- `sequential-scraper.ts` 191-201번 줄을 보면:

  ```typescript
  const currentJob = await supabase
    .from("scraping_jobs")
    .select("status")
    .eq("id", jobId)
    .single();

  if (currentJob.data?.status === "cancelled") {
    return; // 루프 종료
  }
  ```

- 루프 안에서 매번 취소 상태를 체크하는데, 이게 효율적인가요?

**궁금한 점:**

- 1분마다 수집하는데, 취소 체크도 1분마다 하나요?
- 사용자가 취소 버튼을 누르면 언제까지 기다려야 하나요? (최대 1분?)
- 더 빠르게 취소하려면 어떻게 해야 하나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 191-201번 줄
- `components/ScrapingProgress.tsx` 79-104번 줄 (취소 버튼)

---

### 질문 1-4: 1분 대기 중에도 취소할 수 있게 하려면?

**실제 상황:**

- `sequential-scraper.ts` 208-232번 줄을 보면:
  ```typescript
  if (timeSinceLastRequest < minIntervalMs) {
    const waitTime = minIntervalMs - timeSinceLastRequest;
    // 대기 중에도 취소 상태 체크 (1초마다)
    for (let i = 0; i < totalChecks; i++) {
      await new Promise((resolve) => setTimeout(resolve, checkInterval));
      // 취소 상태 체크
    }
  }
  ```
- 1분 대기 중에도 1초마다 취소 상태를 체크하는데, 이게 좋은 방법인가요?

**궁금한 점:**

- 이렇게 하면 취소가 더 빨리 반영되나요?
- 1초마다 데이터베이스를 조회하는 게 부담이 되지 않나요?
- 더 좋은 방법이 있나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 208-232번 줄

---

## 📊 카테고리 2: 진행 상황 표시 관련 질문들

### 질문 2-1: Polling 방식이 효율적인가요?

**실제 상황:**

- `use-scraping-progress.ts` 파일을 보면 5초마다 API를 호출해서 진행 상황을 조회합니다
- 이걸 "Polling" 방식이라고 하는데, 이게 좋은 방법인가요?

**궁금한 점:**

- 5초마다 API를 호출하는 게 서버에 부담이 되지 않나요?
- 사용자가 많아지면 (예: 10명이 동시에 사용) 서버가 느려지지 않나요?
- 다른 방법이 있나요? (예: WebSocket, SSE)

**관련 코드 위치:**

- `hooks/use-scraping-progress.ts` 101-103번 줄
- `components/ScrapingProgress.tsx` 68번 줄

---

### 질문 2-2: Polling 간격을 어떻게 정하나요?

**실제 상황:**

- 현재는 5초마다 조회하는데, 이 간격이 적절한가요?
- 너무 짧으면 서버 부담, 너무 길면 사용자가 진행 상황을 못 봅니다

**궁금한 점:**

- 5초가 적절한 이유가 있나요?
- 작업이 빠르게 진행될 때와 느리게 진행될 때 간격을 다르게 해야 하나요?
- 사용자가 화면을 보고 있지 않을 때는 Polling을 멈춰야 하나요?

**관련 코드 위치:**

- `hooks/use-scraping-progress.ts` 46번 줄 (기본값: 5000ms)

---

## ⚠️ 카테고리 3: 에러 처리와 재시도 로직

### 질문 3-1: 수집 실패 시 재시도 로직이 맞나요?

**실제 상황:**

- `sequential-scraper.ts` 266-291번 줄을 보면:

  ```typescript
  let retryCount = 0;
  const maxRetries = 2; // 최대 2회 재시도

  while (retryCount <= maxRetries) {
    try {
      scrapedProduct = await scrapeSingleProduct(...);
      break; // 성공 시 루프 종료
    } catch (retryError) {
      retryCount++;
      // 지수 백오프 대기 (1초, 2초)
      await new Promise((resolve) => setTimeout(resolve, delaySeconds * 1000));
    }
  }
  ```

- 최대 2회 재시도하고, 실패하면 다음 상품으로 넘어갑니다

**궁금한 점:**

- 2회가 적절한가요? 더 많이 재시도해야 하나요?
- 지수 백오프(1초, 2초)가 적절한가요?
- 아마존이 차단했을 때도 재시도하면 더 차단될 위험이 있지 않나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 266-291번 줄

---

### 질문 3-2: DB 저장 실패 시 재시도가 1회만인 이유는?

**실제 상황:**

- `sequential-scraper.ts` 360-385번 줄을 보면:
  ```typescript
  const maxSaveRetries = 1; // DB 저장은 1회 재시도
  ```
- 수집은 2회 재시도인데, DB 저장은 1회만 재시도합니다

**궁금한 점:**

- 왜 DB 저장은 재시도를 적게 하나요?
- DB 저장이 실패하는 경우가 자주 있나요?
- 실패하면 그 상품은 포기하는 게 맞나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 360-385번 줄

---

### 질문 3-3: Shopify 등록 실패해도 다음 상품으로 계속 가나요?

**실제 상황:**

- `sequential-scraper.ts` 514-518번 줄을 보면:
  ```typescript
  } catch (shopifyError) {
    console.error("❌ Shopify 등록 실패:", shopifyError);
    // Shopify 등록 실패해도 다음 상품 계속 진행
  }
  ```
- Shopify 등록이 실패해도 다음 상품으로 계속 진행합니다

**궁금한 점:**

- 이게 맞는 동작인가요? 실패한 상품은 나중에 수동으로 등록해야 하나요?
- Shopify API가 일시적으로 문제가 있을 때는 어떻게 하나요?
- 실패한 상품 목록을 따로 보여줘야 하나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 514-518번 줄

---

## 🔄 카테고리 4: 서버와 데이터베이스 관련 질문들

### 질문 4-1: 서버가 재시작되면 진행 중인 Job은 어떻게 되나요?

**실제 상황:**

- 사용자가 1000개 수집을 시작했는데, 중간에 서버가 재시작되면?
- 백그라운드에서 돌고 있던 작업이 사라지나요?

**궁금한 점:**

- 서버가 재시작되면 진행 중인 Job은 어떻게 되나요?
- 다시 시작할 수 있나요? 아니면 처음부터 다시 해야 하나요?
- 이런 상황을 대비해야 하나요? 어떻게 대비하나요?

---

### 질문 4-2: 여러 Job이 동시에 실행되면 문제가 생기나요?

**실제 상황:**

- 사용자 A가 1000개 수집 시작 (16.7시간 소요)
- 사용자 B가 동시에 1000개 수집 시작
- 둘 다 같은 서버에서 Puppeteer를 돌리면...

**궁금한 점:**

- 서버가 느려지거나 에러가 날 수 있나요?
- Puppeteer는 동시에 몇 개까지 실행할 수 있나요?
- 사용자별로 제한을 둬야 하나요? (예: 한 사용자는 한 번에 하나만)

---

### 질문 4-3: 데이터베이스 연결이 끊기면 어떻게 하나요?

**실제 상황:**

- 순차 처리 중에 Supabase 연결이 끊기면?
- 진행 상황 업데이트가 실패하면?

**궁금한 점:**

- 연결이 끊기면 자동으로 재연결되나요?
- 재연결이 안 되면 작업이 멈추나요?
- 이런 상황을 어떻게 처리해야 하나요?

---

## 💾 카테고리 5: 데이터 저장과 조회 관련 질문들

### 질문 5-1: Job Item을 왜 따로 저장하나요?

**실제 상황:**

- `scraping_jobs` 테이블과 `scraping_job_items` 테이블이 따로 있습니다
- 각 상품마다 Job Item을 만들어서 상태를 저장합니다

**궁금한 점:**

- 왜 이렇게 나눠서 저장하나요?
- `products` 테이블만 있으면 안 되나요?
- Job Item을 저장하는 게 어떤 이점이 있나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 242-257번 줄 (Job Item 생성)

---

### 질문 5-2: 진행 상황 업데이트가 실패하면?

**실제 상황:**

- `updateJobProgress()` 함수가 실패해도 작업은 계속 진행됩니다 (633번 줄)
- 이게 맞는 동작인가요?

**궁금한 점:**

- 진행 상황 업데이트가 실패해도 작업을 계속하는 게 맞나요?
- 사용자는 진행 상황을 못 보게 되는데, 이게 괜찮나요?
- 재시도 로직을 추가해야 하나요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 613-635번 줄

---

## 🎯 카테고리 6: 실제 사용 중 발생할 수 있는 문제들

### 질문 6-1: 아마존이 차단했을 때 어떻게 알 수 있나요?

**실제 상황:**

- 아마존이 봇으로 인식해서 차단하면 어떤 에러가 나오나요?
- 이걸 어떻게 감지하고 사용자에게 알려줄까요?

**궁금한 점:**

- 차단되었을 때 어떤 에러 메시지가 나오나요?
- 차단을 감지하면 작업을 중단해야 하나요?
- 사용자에게 어떻게 알려줘야 하나요?

---

### 질문 6-2: 1000개 수집 중에 중간에 멈추면?

**실제 상황:**

- 500개 수집했는데 서버가 다운되거나 에러가 나면?
- 나중에 다시 시작할 수 있나요?

**궁금한 점:**

- 중단된 Job을 다시 시작할 수 있나요?
- 500개부터 다시 시작할 수 있나요? 아니면 처음부터?
- 이런 기능이 필요하다면 어떻게 구현하나요?

---

### 질문 6-3: 사용자가 여러 번 "수집 시작"을 누르면?

**실제 상황:**

- 사용자가 실수로 "수집 시작" 버튼을 여러 번 누르면?
- 여러 Job이 동시에 실행되나요?

**궁금한 점:**

- 버튼을 비활성화하는 것만으로 충분한가요?
- 같은 키워드로 여러 Job을 시작하는 걸 막아야 하나요?
- 사용자당 동시에 실행 가능한 Job 개수를 제한해야 하나요?

**관련 코드 위치:**

- `app/dashboard-v2/page.tsx` 307번 줄 (버튼 disabled 처리)

---

## 🔍 카테고리 7: 코드 구조와 설계 관련 질문들

### 질문 7-1: 왜 V1과 V2를 따로 만들었나요?

**실제 상황:**

- `app/dashboard/page.tsx` (V1)와 `app/dashboard-v2/page.tsx` (V2)가 따로 있습니다
- V1은 한 번에 30개, V2는 순차 처리

**궁금한 점:**

- 이렇게 나눈 이유가 뭔가요?
- 나중에 V1을 없애고 V2만 남길 계획인가요?
- 아니면 둘 다 유지해야 하나요?

---

### 질문 7-2: API 경로도 왜 따로 만들었나요?

**실제 상황:**

- `/api/scrape` (V1)와 `/api/scrape-v2` (V2)가 따로 있습니다

**궁금한 점:**

- 이렇게 나눈 이유가 뭔가요?
- 나중에 통합할 계획이 있나요?
- API 버전 관리는 어떻게 하는 게 좋나요?

---

### 질문 7-3: 코드가 너무 길어지면 어떻게 하나요?

**실제 상황:**

- `sequential-scraper.ts` 파일이 776줄이나 됩니다
- `processSequentialScraping()` 함수가 400줄이 넘습니다

**궁금한 점:**

- 이렇게 길어도 괜찮나요?
- 나눠야 한다면 어떻게 나누나요?
- 함수를 작게 나누는 기준이 뭔가요?

**관련 코드 위치:**

- `lib/scraper/sequential-scraper.ts` 153-569번 줄 (processSequentialScraping 함수)

---

## 📝 사용 방법

1. **멘토링 전에 준비하기:**

   - 이 문서에서 실제로 겪은 문제나 궁금한 주제를 선택하세요
   - 관련 코드 위치를 확인하고, 멘토님께 보여드릴 준비를 하세요

2. **멘토링 중:**

   - "실제 상황" 부분을 읽어주시면 멘토님이 이해하기 쉬울 겁니다
   - 코드를 보여드리면서 질문하세요
   - "궁금한 점"을 하나씩 물어보세요

3. **멘토링 후:**
   - 답변받은 내용을 메모해두세요
   - 코드에 주석으로 남겨두면 나중에 참고하기 좋습니다

---

## 🔒 카테고리 8: Rate Limiting과 보안 관련 질문들

### 질문 8-1: Rate Limiter가 메모리에 저장되는 게 문제가 되나요?

**실제 상황:**

- `rate-limiter.ts` 파일을 보면 `requestMap`이라는 Map에 IP별 요청 기록을 저장합니다
- 이건 서버 메모리에 저장되는 건데, 서버가 재시작되면 다 사라집니다

**궁금한 점:**

- 서버가 재시작되면 Rate Limit 기록이 초기화되는데, 이게 괜찮나요?
- 데이터베이스에 저장하는 게 더 나은가요?
- 메모리에 저장하는 것의 장단점이 뭔가요?

**관련 코드 위치:**

- `lib/utils/rate-limiter.ts` 41번 줄 (requestMap)

---

### 질문 8-2: IP 주소를 어떻게 정확히 가져오나요?

**실제 상황:**

- `rate-limiter.ts` 183-199번 줄을 보면 `x-forwarded-for`, `x-real-ip` 헤더를 확인합니다
- Vercel 같은 서비스에서는 실제 IP가 헤더에 들어있습니다

**궁금한 점:**

- 이 방법이 정확한가요?
- 프록시나 CDN을 거치면 IP가 바뀔 수 있나요?
- 여러 IP가 있을 때 첫 번째를 쓰는 게 맞나요?

**관련 코드 위치:**

- `lib/utils/rate-limiter.ts` 183-199번 줄

---

### 질문 8-3: Rate Limit 기록을 언제 정리하나요?

**실제 상황:**

- `rate-limiter.ts` 73-87번 줄을 보면 10분마다 오래된 기록을 정리합니다
- 이게 메모리 누수를 방지하는 거라고 하는데...

**궁금한 점:**

- 10분이 적절한 간격인가요?
- 사용자가 많아지면 이 정리 작업이 부담이 되지 않나요?
- 더 효율적인 방법이 있나요?

**관련 코드 위치:**

- `lib/utils/rate-limiter.ts` 73-87번 줄

---

## 💾 카테고리 9: 데이터베이스 저장 관련 질문들

### 질문 9-1: UPSERT를 쓰는 이유가 뭔가요?

**실제 상황:**

- `save-products.ts` 129-149번 줄을 보면 `upsert`를 사용합니다
- ASIN이 중복되면 업데이트하고, 없으면 새로 만듭니다

**궁금한 점:**

- 왜 INSERT가 아니라 UPSERT를 쓰나요?
- 같은 상품을 여러 번 수집하면 계속 덮어쓰는 게 맞나요?
- 사용자가 수정한 마진율도 덮어쓰나요?

**관련 코드 위치:**

- `lib/utils/save-products.ts` 129-149번 줄

---

### 질문 9-2: 개별 저장 vs 일괄 저장, 뭐가 나은가요?

**실제 상황:**

- `save-products.ts` 104-173번 줄을 보면 `for` 루프로 각 상품을 하나씩 저장합니다
- 30개 상품이 있으면 30번 DB에 접속합니다

**궁금한 점:**

- 이렇게 하나씩 저장하는 게 맞나요?
- 한 번에 여러 개를 저장하는 게 더 빠르지 않나요?
- 에러 처리는 어떻게 하나요? (하나 실패하면 전체 실패?)

**관련 코드 위치:**

- `lib/utils/save-products.ts` 104-173번 줄

---

### 질문 9-3: 가격이 0 이하면 왜 저장을 안 하나요?

**실제 상황:**

- `save-products.ts` 108-118번 줄을 보면 가격이 0 이하면 저장을 건너뜁니다
- 이런 상품은 `failed`로 카운트됩니다

**궁금한 점:**

- 가격이 0인 상품이 실제로 있나요?
- 이런 상품은 왜 수집되었나요? (스크래핑 에러?)
- 사용자에게 알려줘야 하나요?

**관련 코드 위치:**

- `lib/utils/save-products.ts` 108-118번 줄

---

## 🔍 카테고리 10: 필터링과 검색 관련 질문들

### 질문 10-1: 금지어를 매번 DB에서 조회하는 게 문제가 되나요?

**실제 상황:**

- `filter-banned-keywords.ts` 46-82번 줄을 보면 매번 Supabase에서 금지어를 조회합니다
- 상품을 필터링할 때마다 DB 조회가 발생합니다

**궁금한 점:**

- 이게 성능 문제가 되지 않나요?
- 금지어 목록을 캐시(메모리에 저장)하면 안 되나요?
- 금지어가 추가/삭제되면 어떻게 하나요? (캐시 무효화?)

**관련 코드 위치:**

- `lib/utils/filter-banned-keywords.ts` 46-82번 줄

---

### 질문 10-2: 부분 문자열 매칭이 정확한가요?

**실제 상황:**

- `filter-banned-keywords.ts` 91-105번 줄을 보면 `includes()`로 부분 문자열을 확인합니다
- 예: "Nike"가 금지어면 "Nike Air Max"도 필터링됩니다

**궁금한 점:**

- 이게 정확한 방법인가요?
- "Nike"가 포함된 모든 상품을 막는 게 맞나요?
- 더 정확한 매칭 방법이 있나요? (예: 단어 단위 매칭)

**관련 코드 위치:**

- `lib/utils/filter-banned-keywords.ts` 91-105번 줄

---

## 🎨 카테고리 11: UI와 사용자 경험 관련 질문들

### 질문 11-1: 로컬 상태와 서버 상태를 따로 관리하는 이유가 뭔가요?

**실제 상황:**

- `ProductList.tsx` 86-89번 줄을 보면 `localMargins`, `localPrices`라는 로컬 상태가 있습니다
- 마진율을 입력하면 로컬에서 먼저 계산하고, `onBlur`(입력 완료) 시에만 서버에 저장합니다

**궁금한 점:**

- 왜 이렇게 복잡하게 하나요?
- 매번 서버에 저장하면 안 되나요?
- 로컬 상태와 서버 상태가 달라지면 어떻게 하나요?

**관련 코드 위치:**

- `components/ProductList.tsx` 86-89번 줄, 147-182번 줄

---

### 질문 11-2: onBlur로 API를 호출하는 게 맞나요?

**실제 상황:**

- `ProductList.tsx` 177-182번 줄을 보면 마진율 입력이 끝나면(`onBlur`) API를 호출합니다
- 입력하는 중에는(`onChange`) 로컬에서만 계산합니다

**궁금한 점:**

- 이게 좋은 방법인가요?
- 사용자가 입력을 끝내지 않고 다른 곳을 클릭하면 저장이 안 되나요?
- 더 나은 방법이 있나요? (예: 디바운싱, 자동 저장)

**관련 코드 위치:**

- `components/ProductList.tsx` 177-182번 줄

---

### 질문 11-3: 이미지가 없을 때 어떻게 하나요?

**실제 상황:**

- `ProductList.tsx` 267-287번 줄을 보면 이미지가 없으면 "No Image"를 표시합니다
- 하지만 이미지 URL이 있지만 깨진 이미지일 수도 있습니다

**궁금한 점:**

- 이미지가 로드 실패하면 어떻게 하나요?
- 대체 이미지를 보여줘야 하나요?
- 이미지 로딩 중에는 로딩 스피너를 보여줘야 하나요?

**관련 코드 위치:**

- `components/ProductList.tsx` 267-287번 줄

---

## 📡 카테고리 12: API 설계 관련 질문들

### 질문 12-1: 페이지네이션을 어떻게 구현하나요?

**실제 상황:**

- `app/api/products/route.ts` 58-95번 줄을 보면 `limit`과 `offset`을 사용합니다
- 전체 개수를 먼저 조회하고, 그 다음 목록을 조회합니다

**궁금한 점:**

- 이 방법이 효율적인가요?
- 상품이 많아지면 (예: 10만 개) 전체 개수 조회가 느려지지 않나요?
- 더 나은 방법이 있나요? (예: 커서 기반 페이지네이션)

**관련 코드 위치:**

- `app/api/products/route.ts` 58-95번 줄

---

### 질문 12-2: snake_case를 camelCase로 변환하는 게 번거롭지 않나요?

**실제 상황:**

- `app/api/products/route.ts` 111-131번 줄을 보면 DB 데이터를 수동으로 변환합니다
- `row.user_id` → `userId`, `row.amazon_price` → `amazonPrice` 이런 식으로...

**궁금한 점:**

- 이렇게 수동으로 변환하는 게 맞나요?
- 자동으로 변환하는 라이브러리가 있나요?
- 아니면 DB 스키마를 camelCase로 바꾸는 게 나은가요?

**관련 코드 위치:**

- `app/api/products/route.ts` 111-131번 줄

---

### 질문 12-3: 에러 메시지를 사용자에게 어떻게 보여줄까요?

**실제 상황:**

- 모든 API에서 에러가 나면 `error` 필드에 메시지를 넣어서 반환합니다
- 하지만 사용자에게는 "서버 오류가 발생했습니다" 같은 일반적인 메시지만 보입니다

**궁금한 점:**

- 개발자용 에러 메시지와 사용자용 메시지를 따로 만들어야 하나요?
- 어떤 에러는 사용자에게 자세히 보여주고, 어떤 건 숨겨야 하나요?
- 에러 로깅은 어떻게 하나요?

---

## 🕷️ 카테고리 13: 스크래핑 관련 질문들

### 질문 13-1: 여러 selector를 시도하는 게 효율적인가요?

**실제 상황:**

- `amazon-scraper.ts` 198-220번 줄을 보면 여러 selector를 순서대로 시도합니다
- 첫 번째가 실패하면 두 번째, 세 번째... 이런 식으로

**궁금한 점:**

- 이게 좋은 방법인가요?
- 아마존이 페이지 구조를 바꾸면 모든 selector가 실패할 수 있지 않나요?
- 더 안정적인 방법이 있나요?

**관련 코드 위치:**

- `lib/scraper/amazon-scraper.ts` 198-220번 줄

---

### 질문 13-2: 가격 추출이 실패하면 어떻게 하나요?

**실제 상황:**

- `amazon-scraper.ts`에서 가격을 추출하지 못하면 그 상품을 건너뜁니다
- 하지만 가격이 없어도 상품 정보는 유용할 수 있습니다

**궁금한 점:**

- 가격이 없는 상품도 저장해야 하나요?
- 사용자가 나중에 가격을 입력할 수 있게 해야 하나요?
- 가격 추출 실패율이 높으면 어떻게 하나요?

---

### 질문 13-3: 원화 가격을 왜 필터링하나요?

**실제 상황:**

- `amazon-scraper.ts` 354번 줄을 보면 원화(₩) 가격이 감지되면 건너뜁니다
- 아마존 한국 사이트에서 수집된 것 같습니다

**궁금한 점:**

- 이게 자동으로 감지되나요?
- 원화 가격을 달러로 변환하면 안 되나요?
- 다른 통화(유로, 파운드 등)도 필터링해야 하나요?

**관련 코드 위치:**

- `lib/scraper/amazon-scraper.ts` 354번 줄

---

## 🛒 카테고리 14: Shopify 연동 관련 질문들

### 질문 14-1: 이미지 중복 제거를 왜 두 번 하나요?

**실제 상황:**

- `shopify/client.ts` 76-78번 줄을 보면 `deduplicateImages` 함수를 호출합니다
- 그런데 이미 스크래핑 단계에서 중복을 제거했을 수도 있습니다

**궁금한 점:**

- 왜 두 번 체크하나요?
- 성능에 영향이 없나요?
- 어디서 한 번만 체크하는 게 나은가요?

**관련 코드 위치:**

- `lib/shopify/client.ts` 76-78번 줄

---

### 질문 14-2: 재시도 로직이 Shopify 클라이언트와 순차 처리에 따로 있는 이유는?

**실제 상황:**

- `shopify/client.ts`에 재시도 로직이 있고 (175-202번 줄)
- `sequential-scraper.ts`에도 재시도 로직이 있습니다 (473-496번 줄)

**궁금한 점:**

- 왜 두 곳에 있나요?
- 중복되는 건 아닌가요?
- 어느 쪽이 우선 적용되나요?

**관련 코드 위치:**

- `lib/shopify/client.ts` 175-202번 줄
- `lib/scraper/sequential-scraper.ts` 473-496번 줄

---

### 질문 14-3: 일괄 등록에서 0.5초 딜레이가 필요한가요?

**실제 상황:**

- `app/api/shopify/bulk-upload/route.ts` 307-309번 줄을 보면 각 상품 등록 후 0.5초 대기합니다
- `createProduct`에 이미 재시도 로직이 있는데 추가로 대기합니다

**궁금한 점:**

- 이게 정말 필요한가요?
- Shopify Rate Limit이 얼마나 엄격한가요?
- 0.5초가 적절한가요? 더 길어야 하나요?

**관련 코드 위치:**

- `app/api/shopify/bulk-upload/route.ts` 307-309번 줄

---

## 💬 추가 질문이 있으시면

실제 개발 중에 새로운 문제가 생기면, 같은 형식으로 추가해주세요:

- 실제 상황 (어떤 코드를 보고, 어떤 문제가 생겼는지)
- 궁금한 점
- 관련 코드 위치

이렇게 정리해두면 멘토님께 질문하기 훨씬 쉬워집니다!
