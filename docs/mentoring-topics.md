# 멘토링 주제 후보 (실제 개발 중 나온 질문들)

> **대비마마를 위한 멘토링 질문 모음**  
> 실제 프로젝트를 진행하면서 나온 구체적인 질문들을 정리했습니다.

---

## 🔧 카테고리 1: 순차 처리 구현 중 실제로 겪은 문제들

### 질문 1-1: 백그라운드 작업을 어떻게 시작하나요?
**실제 상황:**
- `sequential-scraper.ts` 파일 122번 줄을 보면:
  ```typescript
  processSequentialScraping(job.id, userId, searchInput, totalTarget).catch(...)
  ```
- 이렇게 `.catch()`만 붙이고 `await`를 안 쓰는데, 이게 맞나요?

**궁금한 점:**
- `await`를 안 쓰면 서버가 응답을 보낸 후에도 작업이 계속 진행되나요?
- 만약 `await`를 쓰면 어떻게 되나요? (사용자가 30분 동안 기다려야 하나요?)
- `.catch()`로 에러를 잡는 게 충분한가요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 122번 줄

---

### 질문 1-2: 사용자가 화면을 닫아도 작업이 계속 진행되나요?
**실제 상황:**
- 사용자가 "수집 시작" 버튼을 누르고 화면을 닫으면
- 백그라운드에서 작업이 계속 진행되는지 궁금합니다

**궁금한 점:**
- Next.js 서버에서 시작한 작업은 사용자가 화면을 닫아도 계속 되나요?
- 아니면 사용자가 연결을 끊으면 작업도 중단되나요?
- 나중에 다시 접속했을 때 진행 상황을 볼 수 있나요?

---

### 질문 1-3: 취소 기능은 어떻게 구현하나요?
**실제 상황:**
- `sequential-scraper.ts` 191-201번 줄을 보면:
  ```typescript
  const currentJob = await supabase
    .from("scraping_jobs")
    .select("status")
    .eq("id", jobId)
    .single();

  if (currentJob.data?.status === "cancelled") {
    return; // 루프 종료
  }
  ```
- 루프 안에서 매번 취소 상태를 체크하는데, 이게 효율적인가요?

**궁금한 점:**
- 1분마다 수집하는데, 취소 체크도 1분마다 하나요?
- 사용자가 취소 버튼을 누르면 언제까지 기다려야 하나요? (최대 1분?)
- 더 빠르게 취소하려면 어떻게 해야 하나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 191-201번 줄
- `components/ScrapingProgress.tsx` 79-104번 줄 (취소 버튼)

---

### 질문 1-4: 1분 대기 중에도 취소할 수 있게 하려면?
**실제 상황:**
- `sequential-scraper.ts` 208-232번 줄을 보면:
  ```typescript
  if (timeSinceLastRequest < minIntervalMs) {
    const waitTime = minIntervalMs - timeSinceLastRequest;
    // 대기 중에도 취소 상태 체크 (1초마다)
    for (let i = 0; i < totalChecks; i++) {
      await new Promise((resolve) => setTimeout(resolve, checkInterval));
      // 취소 상태 체크
    }
  }
  ```
- 1분 대기 중에도 1초마다 취소 상태를 체크하는데, 이게 좋은 방법인가요?

**궁금한 점:**
- 이렇게 하면 취소가 더 빨리 반영되나요?
- 1초마다 데이터베이스를 조회하는 게 부담이 되지 않나요?
- 더 좋은 방법이 있나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 208-232번 줄

---

## 📊 카테고리 2: 진행 상황 표시 관련 질문들

### 질문 2-1: Polling 방식이 효율적인가요?
**실제 상황:**
- `use-scraping-progress.ts` 파일을 보면 5초마다 API를 호출해서 진행 상황을 조회합니다
- 이걸 "Polling" 방식이라고 하는데, 이게 좋은 방법인가요?

**궁금한 점:**
- 5초마다 API를 호출하는 게 서버에 부담이 되지 않나요?
- 사용자가 많아지면 (예: 10명이 동시에 사용) 서버가 느려지지 않나요?
- 다른 방법이 있나요? (예: WebSocket, SSE)

**관련 코드 위치:**
- `hooks/use-scraping-progress.ts` 101-103번 줄
- `components/ScrapingProgress.tsx` 68번 줄

---

### 질문 2-2: Polling 간격을 어떻게 정하나요?
**실제 상황:**
- 현재는 5초마다 조회하는데, 이 간격이 적절한가요?
- 너무 짧으면 서버 부담, 너무 길면 사용자가 진행 상황을 못 봅니다

**궁금한 점:**
- 5초가 적절한 이유가 있나요?
- 작업이 빠르게 진행될 때와 느리게 진행될 때 간격을 다르게 해야 하나요?
- 사용자가 화면을 보고 있지 않을 때는 Polling을 멈춰야 하나요?

**관련 코드 위치:**
- `hooks/use-scraping-progress.ts` 46번 줄 (기본값: 5000ms)

---

## ⚠️ 카테고리 3: 에러 처리와 재시도 로직

### 질문 3-1: 수집 실패 시 재시도 로직이 맞나요?
**실제 상황:**
- `sequential-scraper.ts` 266-291번 줄을 보면:
  ```typescript
  let retryCount = 0;
  const maxRetries = 2; // 최대 2회 재시도

  while (retryCount <= maxRetries) {
    try {
      scrapedProduct = await scrapeSingleProduct(...);
      break; // 성공 시 루프 종료
    } catch (retryError) {
      retryCount++;
      // 지수 백오프 대기 (1초, 2초)
      await new Promise((resolve) => setTimeout(resolve, delaySeconds * 1000));
    }
  }
  ```
- 최대 2회 재시도하고, 실패하면 다음 상품으로 넘어갑니다

**궁금한 점:**
- 2회가 적절한가요? 더 많이 재시도해야 하나요?
- 지수 백오프(1초, 2초)가 적절한가요?
- 아마존이 차단했을 때도 재시도하면 더 차단될 위험이 있지 않나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 266-291번 줄

---

### 질문 3-2: DB 저장 실패 시 재시도가 1회만인 이유는?
**실제 상황:**
- `sequential-scraper.ts` 360-385번 줄을 보면:
  ```typescript
  const maxSaveRetries = 1; // DB 저장은 1회 재시도
  ```
- 수집은 2회 재시도인데, DB 저장은 1회만 재시도합니다

**궁금한 점:**
- 왜 DB 저장은 재시도를 적게 하나요?
- DB 저장이 실패하는 경우가 자주 있나요?
- 실패하면 그 상품은 포기하는 게 맞나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 360-385번 줄

---

### 질문 3-3: Shopify 등록 실패해도 다음 상품으로 계속 가나요?
**실제 상황:**
- `sequential-scraper.ts` 514-518번 줄을 보면:
  ```typescript
  } catch (shopifyError) {
    console.error("❌ Shopify 등록 실패:", shopifyError);
    // Shopify 등록 실패해도 다음 상품 계속 진행
  }
  ```
- Shopify 등록이 실패해도 다음 상품으로 계속 진행합니다

**궁금한 점:**
- 이게 맞는 동작인가요? 실패한 상품은 나중에 수동으로 등록해야 하나요?
- Shopify API가 일시적으로 문제가 있을 때는 어떻게 하나요?
- 실패한 상품 목록을 따로 보여줘야 하나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 514-518번 줄

---

## 🔄 카테고리 4: 서버와 데이터베이스 관련 질문들

### 질문 4-1: 서버가 재시작되면 진행 중인 Job은 어떻게 되나요?
**실제 상황:**
- 사용자가 1000개 수집을 시작했는데, 중간에 서버가 재시작되면?
- 백그라운드에서 돌고 있던 작업이 사라지나요?

**궁금한 점:**
- 서버가 재시작되면 진행 중인 Job은 어떻게 되나요?
- 다시 시작할 수 있나요? 아니면 처음부터 다시 해야 하나요?
- 이런 상황을 대비해야 하나요? 어떻게 대비하나요?

---

### 질문 4-2: 여러 Job이 동시에 실행되면 문제가 생기나요?
**실제 상황:**
- 사용자 A가 1000개 수집 시작 (16.7시간 소요)
- 사용자 B가 동시에 1000개 수집 시작
- 둘 다 같은 서버에서 Puppeteer를 돌리면...

**궁금한 점:**
- 서버가 느려지거나 에러가 날 수 있나요?
- Puppeteer는 동시에 몇 개까지 실행할 수 있나요?
- 사용자별로 제한을 둬야 하나요? (예: 한 사용자는 한 번에 하나만)

---

### 질문 4-3: 데이터베이스 연결이 끊기면 어떻게 하나요?
**실제 상황:**
- 순차 처리 중에 Supabase 연결이 끊기면?
- 진행 상황 업데이트가 실패하면?

**궁금한 점:**
- 연결이 끊기면 자동으로 재연결되나요?
- 재연결이 안 되면 작업이 멈추나요?
- 이런 상황을 어떻게 처리해야 하나요?

---

## 💾 카테고리 5: 데이터 저장과 조회 관련 질문들

### 질문 5-1: Job Item을 왜 따로 저장하나요?
**실제 상황:**
- `scraping_jobs` 테이블과 `scraping_job_items` 테이블이 따로 있습니다
- 각 상품마다 Job Item을 만들어서 상태를 저장합니다

**궁금한 점:**
- 왜 이렇게 나눠서 저장하나요?
- `products` 테이블만 있으면 안 되나요?
- Job Item을 저장하는 게 어떤 이점이 있나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 242-257번 줄 (Job Item 생성)

---

### 질문 5-2: 진행 상황 업데이트가 실패하면?
**실제 상황:**
- `updateJobProgress()` 함수가 실패해도 작업은 계속 진행됩니다 (633번 줄)
- 이게 맞는 동작인가요?

**궁금한 점:**
- 진행 상황 업데이트가 실패해도 작업을 계속하는 게 맞나요?
- 사용자는 진행 상황을 못 보게 되는데, 이게 괜찮나요?
- 재시도 로직을 추가해야 하나요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 613-635번 줄

---

## 🎯 카테고리 6: 실제 사용 중 발생할 수 있는 문제들

### 질문 6-1: 아마존이 차단했을 때 어떻게 알 수 있나요?
**실제 상황:**
- 아마존이 봇으로 인식해서 차단하면 어떤 에러가 나오나요?
- 이걸 어떻게 감지하고 사용자에게 알려줄까요?

**궁금한 점:**
- 차단되었을 때 어떤 에러 메시지가 나오나요?
- 차단을 감지하면 작업을 중단해야 하나요?
- 사용자에게 어떻게 알려줘야 하나요?

---

### 질문 6-2: 1000개 수집 중에 중간에 멈추면?
**실제 상황:**
- 500개 수집했는데 서버가 다운되거나 에러가 나면?
- 나중에 다시 시작할 수 있나요?

**궁금한 점:**
- 중단된 Job을 다시 시작할 수 있나요?
- 500개부터 다시 시작할 수 있나요? 아니면 처음부터?
- 이런 기능이 필요하다면 어떻게 구현하나요?

---

### 질문 6-3: 사용자가 여러 번 "수집 시작"을 누르면?
**실제 상황:**
- 사용자가 실수로 "수집 시작" 버튼을 여러 번 누르면?
- 여러 Job이 동시에 실행되나요?

**궁금한 점:**
- 버튼을 비활성화하는 것만으로 충분한가요?
- 같은 키워드로 여러 Job을 시작하는 걸 막아야 하나요?
- 사용자당 동시에 실행 가능한 Job 개수를 제한해야 하나요?

**관련 코드 위치:**
- `app/dashboard-v2/page.tsx` 307번 줄 (버튼 disabled 처리)

---

## 🔍 카테고리 7: 코드 구조와 설계 관련 질문들

### 질문 7-1: 왜 V1과 V2를 따로 만들었나요?
**실제 상황:**
- `app/dashboard/page.tsx` (V1)와 `app/dashboard-v2/page.tsx` (V2)가 따로 있습니다
- V1은 한 번에 30개, V2는 순차 처리

**궁금한 점:**
- 이렇게 나눈 이유가 뭔가요?
- 나중에 V1을 없애고 V2만 남길 계획인가요?
- 아니면 둘 다 유지해야 하나요?

---

### 질문 7-2: API 경로도 왜 따로 만들었나요?
**실제 상황:**
- `/api/scrape` (V1)와 `/api/scrape-v2` (V2)가 따로 있습니다

**궁금한 점:**
- 이렇게 나눈 이유가 뭔가요?
- 나중에 통합할 계획이 있나요?
- API 버전 관리는 어떻게 하는 게 좋나요?

---

### 질문 7-3: 코드가 너무 길어지면 어떻게 하나요?
**실제 상황:**
- `sequential-scraper.ts` 파일이 776줄이나 됩니다
- `processSequentialScraping()` 함수가 400줄이 넘습니다

**궁금한 점:**
- 이렇게 길어도 괜찮나요?
- 나눠야 한다면 어떻게 나누나요?
- 함수를 작게 나누는 기준이 뭔가요?

**관련 코드 위치:**
- `lib/scraper/sequential-scraper.ts` 153-569번 줄 (processSequentialScraping 함수)

---

## 📝 사용 방법

1. **멘토링 전에 준비하기:**
   - 이 문서에서 실제로 겪은 문제나 궁금한 주제를 선택하세요
   - 관련 코드 위치를 확인하고, 멘토님께 보여드릴 준비를 하세요

2. **멘토링 중:**
   - "실제 상황" 부분을 읽어주시면 멘토님이 이해하기 쉬울 겁니다
   - 코드를 보여드리면서 질문하세요
   - "궁금한 점"을 하나씩 물어보세요

3. **멘토링 후:**
   - 답변받은 내용을 메모해두세요
   - 코드에 주석으로 남겨두면 나중에 참고하기 좋습니다

---

## 💬 추가 질문이 있으시면

실제 개발 중에 새로운 문제가 생기면, 같은 형식으로 추가해주세요:
- 실제 상황 (어떤 코드를 보고, 어떤 문제가 생겼는지)
- 궁금한 점
- 관련 코드 위치

이렇게 정리해두면 멘토님께 질문하기 훨씬 쉬워집니다!
